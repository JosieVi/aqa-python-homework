# TODO: 7.12 Передача аргументов декораторам

# Подвиг 1. На вход программе подаются целые числа, записанные через пробел. Прочитайте эту строку и сохраните через какую-либо переменную.
# Напишите функцию, которая имеет один параметр, преобразовывает переданную ей строку в список чисел и возвращает их сумму.
# Определите декоратор для этой функции, который имеет один параметр start - начальное значение суммы.
# Примените декоратор со значением start=5 к функции и вызовите декорированную функцию для прочитанной строки. Результат (сумму) отобразите на экране.
# Sample Input:
# 5 6 3 6 -4 6 -1
# Sample Output:
# 26

from functools import wraps

numbers_input = input()

def add_start(start):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):           
            return func(*args, **kwargs) + start
        return wrapper
    return decorator

def get_sum(numbers):
    return sum(map(int, numbers.split()))

result = add_start(start = 5)(get_sum)(numbers_input)
print(result)


# Подвиг 2. Объявите функцию, которая переводит символы строки в нижний регистр (малые буквы) и возвращает результат. 
# Определите декоратор для этой функции, который имеет один параметр tag, определяющий строку с названием тега и начальным значением "h1". Этот декоратор должен заключать возвращенную функцией строку в тег tag и возвращать результат.
# Пример заключения строки "python" в тег h1:
# <h1>python</h1>
# Примените декоратор со значением tag="div" к функции и вызовите декорированную функцию для строки s, прочитанной из входного потока:
# s = input()                  
# Результат работы декорированной функции отобразите на экране
# Sample Input:
# Декораторы - это классно!
# Sample Output:
# <div>декораторы - это классно!</div>

s = input()

def decorator1(tag="h1"):
    def decorator1(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return f'<{tag}>{func(*args, **kwargs)}</{tag}>'
        return wrapper
    return decorator1

def get_lower(s):
    return s.lower()

result = decorator1(tag="div")(get_lower)(s)
print(result)


# Подвиг 3. Объявите функцию, которая принимает строку с кириллицей (и другими символами) и преобразовывает русские буквы в латиницу, используя следующий словарь для замены русских букв на соответствующее латинское написание:
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}                 
# Функция должна возвращать преобразованную строку. Замены делать без учета регистра (переданную строку перевести в нижний регистр - малые буквы). 
# Определите декоратор с параметром chars и начальным значением " !?", который данные символы преобразует в символ "-" и, кроме того, все подряд идущие дефисы (например, "--" или "---") приводит к одному дефису. Полученный результат должен возвращаться в виде строки.
# Примените декоратор с аргументом chars="?!:;,. " к функции и вызовите декорированную функцию для строки s:
# s = input()                 
# Результат работы декорированной функции отобразите на экране.
# Sample Input:
# Декораторы - это круто!
# Sample Output:
# dekoratory-eto-kruto-

s = input()
t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}

def decorator(chars=" !?"):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            for char in chars:
                result = result.replace(char, '-')
            while '--' in result:
                result = result.replace('--', '-')
            return result
        return wrapper
    return decorator

def to_latin(s, sep='-'):
    s = s.lower()
    for key, value in t.items():
        s = s.replace(key, value)
    s = s.replace(' ', sep)
    return s

decorated_result = decorator(chars="?!:;,. ")(to_latin)(s)
print(decorated_result)


# Подвиг 4. Объявите функцию с именем get_list, одним параметром и следующим описанием в теле функции:
# '''Функция для формирования списка целых значений'''
# Сама функция должна формировать и возвращать список целых чисел, который передается ей на вход в виде строки из целых чисел, записанных через пробел.
# Определите декоратор, который выполняет суммирование значений списка, возвращаемого декорируемой функцией и возвращает результат. Внутри декоратора декорируйте переданную функцию с помощью команды @wraps (не забудьте сделать импорт: from functools import wraps).
# Такое декорирование необходимо, чтобы исходная функция get_list сохраняла свои локальные свойства: __name__ и __doc__.
# Примените декоратор к функции get_list, но не вызывайте ее.

def decorator_sum(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return sum(result)
    return wrapper

@decorator_sum
def get_list(s):
    '''Функция для формирования списка целых значений'''
    return list(map(int, s.split()))