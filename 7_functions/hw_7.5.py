# TODO: 7.5 Функции с произвольным числом параметров

# Подвиг 2. Объявите в программе функцию с именем get_even, которая способна принимать произвольное количество чисел в качестве аргументов. Например:
# get_even(1, 2, 3, -5, 10, 8)                  
# Функция должна возвращать список, составленный только из четных переданных ей значений.
# P.S. Функцию вызывать не нужно, только определить.
# Sample Input:
# 45 4 8 11 12 0
# Sample Output:
# 4 8 12 0

def get_even(*args):
    return [x for x in args if x % 2 == 0]


# Подвиг 3. Объявите в программе функцию с именем get_biggest_city, которой можно передавать произвольное количество названий городов (строк) через аргументы. Например:
# get_biggest_city('Город 1', 'Город 2', 'Город 3', 'Город 4')                  
# Данная функция должна возвращать название города (строку) наибольшей длины. Если таких городов несколько, то первый переданный (из наибольших). Программу реализовать без использования сортировки.
# P.S. Функцию выполнять не нужно, только определить.
# Sample Input:
# Питер Москва Самара Воронеж
# Sample Output:
# Воронеж

def get_biggest_city(*cities):
    biggest_city = cities[0]
    for city in cities:
        if len(city) > len(biggest_city):
            biggest_city = city
    return biggest_city



# Подвиг 4. Объявите в программе функцию с именем get_data_fig для вычисления периметра произвольного N-угольника. На вход этой функции передаются N длин сторон через ее аргументы. Дополнительно могут быть указаны именованные аргументы:
# tp - булево значение True/False;
# color - целое числовое значение;
# closed - булево значение True/False;
# width - вещественное значение.
# Функция должна возвращать в виде кортежа периметр многоугольника и указанные значения именованных параметров в порядке их перечисления в тексте задания (если они были переданы). Если какой-либо параметр отсутствует, его возвращать не нужно (пропустить).
# P.S. Функцию выполнять не нужно, только объявить.
# Sample Input:
# 1 2 3 4 3 2 4
# Sample Output:
# 19
# 19 True
# 19 True 7
# 19 False 2.0

def get_data_fig(*sides, **kwargs):
    perimeter = sum(sides)
    result = [perimeter]
    if 'tp' in kwargs:
        result.append(kwargs['tp'])
    if 'color' in kwargs:
        result.append(kwargs['color'])
    if 'closed' in kwargs:
        result.append(kwargs['closed'])
    if 'width' in kwargs:
        result.append(kwargs['width'])
    return tuple(result)


# Большой подвиг 5. (Для закрепления предыдущего материала). На вход программе подается таблица целых чисел (см. пример ниже) размером N x N элементов (N определяется по входным данным). Эти числа сохранены в виде двумерного (вложенного) списка lst2D размером N x N элементов. Полученная таблица содержит нули и кое-где единицы. С помощью функции с именем verify, на вход которой подается двумерный список чисел lst2D (первый параметр), необходимо проверить, являются ли единицы изолированными друг от друга, то есть, вокруг каждой единицы должны быть нули.
# Рекомендуется следующий алгоритм. В функции verify производить перебор двумерного списка. Для каждого элемента (списка) со значением 1 вызывать еще одну вспомогательную функцию is_isolate для проверки изолированности единицы. То есть, функция is_isolate должна возвращать True, если единица изолирована и False в противном случае.
# Как только встречается не изолированная единица, функция verify должна возвращать False. Если успешно доходим (по элементам списка) до конца, то возвращается значение True.
# Функцию verify выполнять не нужно, только объявить.
# P. S. При реализации функции is_isolate не следует прописывать восемь операторов if. Подумайте, как это можно сделать красивее (с точки зрения реализации алгоритма). 
# Sample Input:
# 1 0 0 0 0
# 0 0 1 0 0
# 0 0 0 0 0
# 0 1 0 1 0
# 0 0 0 0 0
# Sample Output:
# True

import sys

def is_isolate(lst2D, row, col):
    rows = len(lst2D)
    cols = len(lst2D[0])
    for i in range(max(0, row - 1), min(rows, row + 2)):
        for j in range(max(0, col - 1), min(cols, col + 2)):
            if (i != row or j != col) and lst2D[i][j] == 1:
                return False
    return True

def verify(lst2D):
    for i in range(len(lst2D)):
        for j in range(len(lst2D[i])):
            if lst2D[i][j] == 1:
                if not is_isolate(lst2D, i, j):
                    return False
    return True

lines = sys.stdin.readlines()
lst2D = [list(map(int, x.strip().split())) for x in lines]


# Значимый подвиг 6. (Для закрепления предыдущего материала). Объявите в программе функцию с именем str_min, которая сравнивает две переданные строки (через два первых параметра) и возвращает минимальную из них (то есть, выполняется лексикографическое сравнение строк). Следом объявите еще две аналогичные функции:
# с именем str_min3 для поиска минимальной строки из трех переданных строк;
# с именем str_min4 для поиска минимальной строки из четырех переданных строк.
# Причем при реализации функций str_min3 и str_min4 следует использовать вызов (результат работы) функции str_min.
# P.S. Выполнять функции не нужно, только объявить.

def str_min(s1, s2):
    return s1 if s1 < s2 else s2

def str_min3(s1, s2, s3):
    return str_min(str_min(s1, s2), s3)

def str_min4(s1, s2, s3, s4):
    return str_min(str_min3(s1, s2, s3), s4)