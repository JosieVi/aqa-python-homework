# TODO: 7.10 Замыкания в Python. Вложенные функции

# Подвиг 1. Объявите внешнюю функцию с именем counter_add и следующей сигнатурой:
# def counter_add(): ...                
# В функции counter_add объявите вложенную функцию с одним параметром. При этом внешняя функция counter_add должна возвращать ссылку на вложенную функцию. Это и есть реализация замыкания.
# Вложенная функция должна увеличивать значение переданного аргумента (через ее единственный параметр) на 5 и возвращать вычисленный результат. 
# После этого вызовите в программе функцию counter_add и результат ее работы присвойте переменной с именем cnt. То есть, переменная cnt будет ссылаться на вложенную функцию. Затем, вызовите внутреннюю функцию через переменную cnt со значением k, которое следует прочитать из входного потока командой:
# k = int(input())                  
# Выведите результат работы вложенной функции на экран.
# Sample Input:
# 7
# Sample Output:
# 12

def counter_add1():
    def inner(k):
        return k + 5
    return inner

cnt = counter_add1()
k = int(input())
print(cnt(k))


# Подвиг 2. Объявите внешнюю функцию с именем counter_add и следующей сигнатурой:
# def counter_add(n): ...              
# В функции counter_add, объявите вложенную функцию, которая имеет один параметр и увеличивает его значение на величину n - параметр внешней функции. При этом внешняя функция counter_add должна возвращать ссылку на вложенную функцию.
# Вызовите внешнюю функцию counter_add со значением аргумента 2 и результат присвойте переменной cnt. То есть, переменная cnt будет ссылаться на вложенную функцию. Вызовите внутреннюю функцию через переменную cnt со значением k, , которое следует прочитать из входного потока командой:
# k = int(input())            
# Выведите результат работы вложенной функции на экран.
# Sample Input:
# 5
# Sample Output:
# 7

def counter_add(n):
    def inner(k):
        return k + n
    return inner

cnt = counter_add(2)
k = int(input())
print(cnt(k))


# Подвиг 3. Реализуйте в программе следующее замыкание функций. Объявите внешнюю функцию без параметров. В ее теле объявите вложенную функцию с одним параметром, в который будет передаваться строка. При этом внешняя функция должна возвращать ссылку на вложенную функцию. Вложенная функция должна заключать переданную через параметр строку в тег h1 и возвращать результат. Например, подается строка "Python", вложенная функция должна вернуть строку:
# "<h1>Python</h1>"
# Далее, на вход программы поступает строка, которую следует прочитать из входного потока. Затем, вызовите внешнюю функцию для получения ссылки на вложенную функцию. Через эту ссылку вызовите вложенную функцию с передачей ей прочитанной строки. Результат работы вложенной функции выведите на экран.
# Sample Input:
# Balakirev
# Sample Output:
# <h1>Balakirev</h1>

def wrap_tag1():
    def inner(str):
        return f"<h1>{str}</h1>"
    return inner

input_str = input()
func = wrap_tag1()
print(func(input_str))


# Подвиг 4. Реализуйте в программе следующее замыкание функций. Объявите внешнюю функцию с одним параметром tag, в который будет передаваться тег (строка). В теле внешней функции объявите вложенную функцию с одним параметром, в который будет передаваться строка, заключаемая в тег. При этом внешняя функция должна возвращать ссылку на вложенную функцию. Вложенная функция должна заключать переданную через параметр строку в тег tag, содержащийся в параметре внешней функции и возвращать результат. Например, подается строка "Python", параметр tag="div", вложенная функция должна вернуть строку:
# "<div>Python</div>"
# Далее, на вход программы поступают две строки: первая с тегом, вторая с некоторым содержимым. Прочитайте эти строки и вызовите внешнюю функцию с передачей ей прочитанного тега. Через ссылку на вложенную функцию вызовите ее с передачей ей прочитанной (второй) строки. Результат работы вложенной функции выведите на экран.
# Sample Input:
# div
# Сергей Балакирев
# Sample Output:
# <div>Сергей Балакирев</div>


def wrap_tag2(tag):
    def inner(str):
        return f"<{tag}>{str}</{tag}>"
    return inner

input_tag = input()
input_str = input()
func = wrap_tag2(input_tag)
print(func(input_str))


# Подвиг 5. Реализуйте в программе следующее замыкание функций. Объявите внешнюю функцию с одним параметром tp, в который будет передаваться тип коллекции (строка). В теле внешней функции объявите вложенную функцию с одним параметром, которая преобразует строку (переданную через параметр) с набором целых чисел, записанных через пробел, либо в список, либо в кортеж. Тип коллекции определяется параметром tp внешней функции. Если tp = 'list', то используется список, иначе (при другом значении) - кортеж. При этом внешняя функция должна возвращать ссылку на вложенную функцию.
# Далее, на вход программы поступают две строки: первая - это значение для параметра tp; вторая - последовательность целых чисел, записанных через пробел. Прочитайте их и с помощью реализованного замыкания преобразуйте эти данные в соответствующую коллекцию. Результат работы вложенной функции (сохраненный через переменную lst) выведите на экран командой:
# print(lst)           
# Обратите внимание, что в возвращаемой коллекции должны присутствовать числа, а не их строковые представления.
# Sample Input:
# list
# -5 6 8 11 0 111 -456 3
# Sample Output:
# [-5, 6, 8, 11, 0, 111, -456, 3]


def wrap_collection(collection_type):
    def inner(str):
        if collection_type == 'list':
            return list(map(int, str.split()))
        else:
            return tuple(map(int, str.split()))
    return inner

input_type = input()
input_str = input()
func = wrap_collection(input_type)
print(func(input_str))