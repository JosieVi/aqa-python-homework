# TODO: 7.7 Рекурсивные функции

# Подвиг 2. На вход программе подается целое положительное число N. Необходимо написать рекурсивную функцию с именем get_rec_N, которая отображает на экране последовательность целых чисел от 1 до N (включительно). Каждое число выводится с новой строки. 
# В качестве единственного параметра функция get_rec_N должна принимать числовое значение. Начальный вызов функции уже дан в программе и выглядит так:
# get_rec_N(N)
# Sample Input:
# 8
# Sample Output:
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8

import numbers


N = int(input())
i = 1
def get_rec_N(n):
    global i
    if i > n:
        return
    print(i)
    i += 1
    get_rec_N(n)

get_rec_N(N)


# Подвиг 3. На вход программе подаются целые числа, записанные через пробел. Необходимо их прочитать и сохранить в виде списка (или кортежа). Затем, объявить рекурсивную функцию с именем get_rec_sum для вычисления суммы прочитанных чисел. То есть, функция get_rec_sum в итоге должна возвращать значение суммы. (Выводить на экран она ничего не должна). Первым параметром в функцию следует передавать список чисел. Остальные параметры продумайте самостоятельно.
# Вызовите функцию get_rec_sum и выведите на экран значение суммы, которое она вернула.
# Sample Input:
# 8 11 -5 4 3
# Sample Output:
# 21
        
numbers = list(map(int, input().split()))

def get_rec_sum(n):
    if len(n) == 1:
        return n[0]
    return n[0] + get_rec_sum(n[1:])

print(get_rec_sum(numbers))


# Подвиг 4. На вход программе подается натуральное число N (N >= 2), которое читается с помощью команды:
# N = int(input())            
# Необходимо с помощью рекурсивной функции сигнатуры:
# def fib_rec(N, f=[1, 1]): ...                
# (здесь N - общее количество чисел Фибоначчи; f - начальный список этих чисел) сформировать последовательность чисел Фибоначчи по правилу: первые два числа равны 1 и 1, а каждое следующе значение равно сумме двух предыдущих. Пример такой последовательности для первых 7 чисел: 1, 1, 2, 3, 5, 8, 13, ...
# Функция должна возвращать список сформированной последовательности длиной N. Вызывать функцию не нужно, только объявить.
# Sample Input:
# 7
# Sample Output:
# 1 1 2 3 5 8 13

N = int(input())

def fib_rec(N, f=[1, 1]):
    if len(f) == N:
        return f
    f.append(f[-1] + f[-2])
    return fib_rec(N, f)

print(*fib_rec(N))


# Подвиг 5. На вход программе подается целое неотрицательное число n, которое читается командой:
# n = int(input())                  
# Необходимо объявить рекурсивную функцию fact_rec со следующей сигнатурой:
# def fact_rec(n): ...               
# для вычисления факториала числа n.
# Функция должна возвращать вычисленное значение. Вызывать функцию не нужно, только объявить.
# Sample Input:
# 6
# Sample Output:
# 720

n = int(input())

def fact_rec(n):
    if n == 0:
        return 1
    return n * fact_rec(n-1)


# Подвиг 6. В программе объявлен следующий многомерный список:
# d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]                  
# С помощью рекурсивной функции get_line_list необходимо на его основе создать одномерный список из значений элементов списка d. Функция должна возвращать новый созданный одномерный список.  (Только возвращать, выводить на экран ничего не нужно.)
# Вызывать функцию не нужно, только объявить со следующей сигнатурой:
# def get_line_list(d,a=[]): ...                  
# где d - исходный список; a - новый формируемый.

d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]

def get_line_list(d, a=[]):
    for el in d:
        if isinstance(el, list):
            get_line_list(el, a)
        else:
            a.append(el)
    return a


# Подвиг 7. Лягушка прыгает вперед и может скакнуть либо на одно деление, либо сразу на два. Наша задача определить количество вариантов маршрутов, которыми лягушка может достичь риски под номером N (натуральное число N подается на вход программе).
# Решать задачу следует с применением рекурсивной функции. Назовем ее get_path. Алгоритм решения следующий. Рассмотрим, например, риску под номером 4. Очевидно, в нее лягушка может скакнуть либо с риски номер 2, либо с риски номер 3. Значит, общее число вариантов перемещений лягушки можно определить как: 
# get_path(4) = get_path(3) + get_path(2)               
# Аналогично будет справедливо и для любой риски N:
# get_path(N) = get_path(N-1) + get_path(N-2)              
# А начальные условия задачи, следующие:
# get_path(1) -> 1
# get_path(2) -> 2
# Реализуйте такую рекурсивную функцию, которая должна возвращать количество вариантов перемещений лягушки для риски под номером N.
# Вызовите эту функцию для введенного числа N и отобразите результат на экране.
# Sample Input:
# 7
# Sample Output:
# 21

def get_path(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
    return get_path(n-1) + get_path(n-2)

N = int(input())
print(get_path(N))


# Великий подвиг 8. На вход программе подаются целые числа, записанные через пробел. Необходимо их прочитать и сохранить в списке. Затем, выполнить сортировку этого списка по возрастанию с помощью алгоритма сортировки слиянием. Функция должна возвращать новый отсортированный список.
# Вызовите результирующую функцию сортировки для введенного списка и отобразите результат на экран в виде последовательности чисел, записанных через пробел.
# Подсказка: для разбиения списка и его последующей сборки используйте рекурсивные функции.
# P. S. Теория сортировки в видео предыдущего шага.
# Sample Input:
# 8 11 -6 3 0 1 1
# Sample Output:
# -6 0 1 1 3 8 11

def merge(lst1, lst2):
    res, i, j = [], 0, 0
    while lst1 and lst2:
        res.append((lst1, lst2)[lst1[-1] < lst2[-1]].pop())
    return lst1 + lst2 + res[::-1]

def merge_sort(lst):
    hl = len(lst) // 2
    return hl and merge(merge_sort(lst[:hl]), merge_sort(lst[hl:])) or lst

lst = list(map(int, input().split()))

print(*merge_sort(lst))