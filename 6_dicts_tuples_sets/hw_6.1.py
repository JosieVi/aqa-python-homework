from itertools import count
import numbers
from random import sample
from tkinter import PhotoImage
from unittest import result
import pytest

# TODO: 6.1 Введение в словари

# Подвиг 3. На вход программе подаются данные в формате ключ=значение, записанные через пробел. Значениями здесь являются целые числа (см. пример ниже). Необходимо прочитать строку с этими данными и на их основе сформировать словарь d, используя функцию dict(). Результирующий словарь вывести на экран командой:
# print(*sorted(d.items()))
# # Sample Input:
# one=1 two=2 three=3
# Sample Output:
# ('one', 1) ('three', 3) ('two', 2)

sample_input = input().split()

d = dict((el.split('=')[0], int(el.split('=')[1])) for el in sample_input)

print(*sorted(d.items()))


# Подвиг 4. На вход программе поступают данные в виде набора строк в формате: 
# ключ1=значение1
# ключ2=значение2
# ...
# ключN=значениеN
# Ключами здесь выступают целые числа (см. пример ниже). В программе уже реализовано считывание всех строк и сохранение их в виде списка:
# lst_in = list(map(str.strip, sys.stdin.readlines()))               
# Необходимо преобразовать список lst_in в словарь d (без использования функции dict()) и вывести полученный словарь на экран командой:
# print(*sorted(d.items()))            
# Sample Input:
# 5=отлично
# 4=хорошо
# 3=удовлетворительно
# Sample Output:
# (3, 'удовлетворительно') (4, 'хорошо') (5, 'отлично')

import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))   
d = {}

for el in lst_in:
    key, value = el.split('=')
    d[int(key)] = value

print(*sorted(d.items())) 


# Подвиг 5. На вход программе подаются данные в формате ключ=значение, записанные через пробел. Необходимо прочитать строку с этими данными и на их основе сформировать словарь. Затем проверить, существуют ли в словаре ключи: 'house', 'True' и '5' (все ключи - строки). Если все они существуют, то вывести на экран "ДА", иначе "НЕТ".
# Sample Input:
# вологда=город house=дом True=1 5=отлично 9=божественно
# Sample Output:
# ДА

sample_input = input().split()
d = dict((el.split('=')[0], el.split('=')[1]) for el in sample_input)
keys_to_check = ['house', 'True', '5']
flag = True
for key in keys_to_check:
    if key not in d:
        flag = False
        break

print("ДА" if flag else "НЕТ")


# Подвиг 6. На вход программе подаются данные в формате ключ=значение, записанные через пробел. Необходимо прочитать строку с этими данными и на их основе сформировать словарь d. Затем удалить из этого словаря ключи 'False' и '3', если они существуют. Ключами и значениями словаря являются строки. Вывести полученный словарь на экран командой:
# print(*sorted(d.items()))
# Sample Input:
# лена=имя дон=река москва=город False=ложь 3=удовлетворительно True=истина
# Sample Output:
# ('True', 'истина') ('дон', 'река') ('лена', 'имя') ('москва', 'город')

sample_input = input().split()
d = dict((el.split('=')[0], el.split('=')[1]) for el in sample_input)

keys_to_remove = ['False', '3']
for key in keys_to_remove:
    if key in d:
        del d[key]

print(*sorted(d.items()))


# Подвиг 7. На вход программе подаются номера телефонов, записанные в одну строчку через пробел, с разными кодами стран: +7, +6, +2, +4 и т.д. Необходимо прочитать строку и на ее основе сформировать словарь d. Ключами словаря должны быть коды (строки: +7, +6, +2 и т. п.), а значениями список номеров в виде строк (следующих в том же порядке, что и в исходной строке) с соответствующими кодами. Полученный словарь вывести командой:
# print(*sorted(d.items()))
# Sample Input:
# +71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890
# Sample Output:
# ('+2', ['+21235777890', '+21234567110']) ('+5', ['+52134567890']) ('+6', ['+61234576890']) ('+7', ['+71234567890', '+71234567854', '+71232267890'])

phones = input().split()
d = {}

for phone in phones:
    code = phone[:2]
    if code in d:
        d[code].append(phone)
    else:
        d[code] = [phone]

print(*sorted(d.items()))


# Подвиг 8. На вход программе поступают номера телефонов с привязкой к именам в виде строк следующего формата:
# номер_1 имя_1
# номер_2 имя_2
# ...
# номер_N имя_N
# В программе уже реализовано считывание всех строк и сохранение их в виде списка:
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# На основе списка lst_in необходимо создать словарь d, где ключами будут имена, а значениями - список номеров телефонов для этого имени (ключа). Обратите внимание, что одному имени может принадлежать несколько разных номеров. Полученный словарь вывести командой:
# print(*sorted(d.items()))    
# Sample Input:
# +71234567890 Сергей
# +71234567810 Сергей
# +51234567890 Михаил
# +72134567890 Николай
# Sample Output:
# ('Михаил', ['+51234567890']) ('Николай', ['+72134567890']) ('Сергей', ['+71234567890', '+71234567810'])

import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))
d = {}

for el in lst_in:
    phone, name = el.split()
    if name in d:
        d[name].append(phone)
    else:
        d[name] = [phone]

print(*sorted(d.items())) 


# Подвиг 9. На вход программе поступают целые положительные числа. Необходимо с помощью цикла реализовать их считывание, пока не встретится число 0. В теле цикла для каждого прочитанного числа вычисляется квадратный корень (с точностью до сотых) и значение выводится на экран (в столбик). С помощью словаря выполните кэширование данных так, чтобы при повторном вводе того же самого числа результат не вычислялся, а бралось ранее вычисленное значение (из словаря). При этом на экране должно выводиться:
# значение из кэша: <число>
# Sample Input:
# 1
# 2
# 3
# 3
# 2
# 4
# 0
# Sample Output:
# 1.0
# 1.41
# 1.73
# значение из кэша: 1.73
# значение из кэша: 1.41
# 2.0

d = {}

while True:
    n = int(input())
    if n == 0:
        break
    if n in d:
        print(f'значение из кэша: {d[n]}')
    else:
        d[n] = round(n ** 0.5, 2)
        print(d[n])


# Подвиг 10. Тестовый веб-сервер возвращает HTML-страницы по URL-адресам (строкам). На вход программе поступают различные URL-адреса, записанные каждое с новой строки. В программе уже реализовано считывание всех строк и сохранение их в виде списка:
# lst_in = list(map(str.strip, sys.stdin.readlines()))                
# Необходимо перебрать в цикле этот список с URL-адресами и если адрес появился (пришел) впервые, то на экране отобразить строку (без кавычек):
# "HTML-страница для адреса <URL-адрес>"
# и сохранить в словаре эту строку с ключом текущего URL-адреса. Если же URL-адрес встречается (приходит) повторно (проверяется по ключам словаря), то следует взять строку "HTML-страница для адреса <URL-адрес>" из этого словаря и вывести на экран сообщение (без кавычек):
# "Взято из кэша: HTML-страница для адреса <URL-адрес>"
# Сообщения выводить каждое с новой строки.
# P.S. Подобные задачи на практике решаются через хэш-таблицы. В Python словарь - это хэш-таблица. Скорость поиска ключа в нем выполняется очень быстро (намного быстрее, чем в списке). Именно поэтому решать ее через список очень плохая практика.
# Sample Input:
# ustanovka-i-zapusk-yazyka
# ustanovka-i-poryadok-raboty-pycharm
# peremennyye-operator-prisvaivaniya-tipy-dannykh
# arifmeticheskiye-operatsii
# ustanovka-i-poryadok-raboty-pycharm
# Sample Output:
# HTML-страница для адреса ustanovka-i-zapusk-yazyka
# HTML-страница для адреса ustanovka-i-poryadok-raboty-pycharm
# HTML-страница для адреса peremennyye-operator-prisvaivaniya-tipy-dannykh
# HTML-страница для адреса arifmeticheskiye-operatsii
# Взято из кэша: HTML-страница для адреса ustanovka-i-poryadok-raboty-pycharm

import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))

d = {}
for url in lst_in:
    if url in d:
        print(f'Взято из кэша: {d[url]}')
    else:
        d[url] = f'HTML-страница для адреса {url}'
        print(d[url])