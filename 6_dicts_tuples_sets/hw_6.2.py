# TODO: 6.2 Методы словаря. Перебор его элементов в цикле

# Подвиг 3. На вход программе подается строка из русских букв и символов пробела. Необходимо ее прочитать и закодировать азбукой Морзе, где каждой букве ставится в соответствие код из точки и тире. После каждой закодированной буквы должен стоять пробел (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки). Коды азбуки Морзе приведены ниже для русского алфавита и символа пробела:
# morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ё': '.', 'ж': '...-', 'з': '--..', 'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.', 'с': '...', 'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----', 'щ': '--.-', 'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-...-'}
# Результат кодирования вывести в виде строки.
# Sample Input:
# Сергей Балакирев
# Sample Output:
# ... . .-. --. . .--- -...- -... .- .-.. .- -.- .. .-. . .--

import string
from turtle import update


morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ё': '.', 'ж': '...-', 'з': '--..', 'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.', 'с': '...', 'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----', 'щ': '--.-', 'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-...-'}
# sample_input = input().lower()
sample_input = 'Сергей Балакирев'.lower()
sample_output = []
for ch in sample_input:
    sample_output.append(morze[ch])
print(' '.join(sample_output)) 


# Подвиг 4. На вход программе подается закодированная строка с помощью азбуки Морзе. Коды разделены между собой пробелом. Необходимо ее раскодировать, используя азбуку Морзе из предыдущего занятия. Все буквы в строке должны быть малыми (нижний регистр). Полученное сообщение (строку) вывести на экран.
# P.S. Буквам е(ё) соответствует один и тот же код Морзе, поэтому всюду подставляется буква 'е'.
# Sample Input:
# .-- ... . -...- .-- . .-. -. ---
# Sample Output:
# все верно

morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ё': '.', 'ж': '...-', 'з': '--..', 'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.', 'с': '...', 'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----', 'щ': '--.-', 'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-...-'}
sample_input = input().split()
sample_output = []
for code in sample_input:
    for k, v in morze.items():
        if code == v:
            sample_output.append(k)
            break
print(''.join(sample_output))


# Подвиг 5. На вход программе подается список целых чисел, записанных в одну строчку через пробел. Необходимо их прочитать и сохранить в виде списка. Затем, с помощью словаря выделите только уникальные (не повторяющиеся) числа. Сформируйте из них еще один список (уникальных чисел). Числа в этом списке должны идти в том же порядке, что и при чтении (из входного потока). Выведите уникальные числа на экран в одну строчку через пробел.
# P. S. Такая задача, обычно решается через множества, но мы их еще не проходили, поэтому воспользуемся словарем.
# Sample Input:
# 8 11 -4 5 2 11 4 8
# Sample Output:
# 8 11 -4 5 2 4

sample_input = list(map(int, input().split()))
d = {}
for number in sample_input:
    if number not in d:
        d[number] = True
unique_numbers = list(d.keys())
print(*unique_numbers)


# Подвиг 6. На вход программе подаются строки в формате:
# <день рождения 1> имя_1
# <день рождения 2> имя_2
# ...
# <день рождения N> имя_N
# Дни рождений и имена могут повторяться.
# В программе уже реализовано их считывание и сохранение в списке:
# lst_in = list(map(str.strip, sys.stdin.readlines()))              
# На основе списка lst_in сформировать словарь, где ключи - дни рождения (целое число), а значения - имена (строка). Выведите полученный словарь в формате (см. пример ниже):
# день рождения 1: имя1, ..., имяN1
# день рождения 2: имя1, ..., имяN2
# ...
# день рождения M: имя1, ..., имяNM
# Sample Input:
# 3 Сергей
# 5 Николай
# 4 Елена
# 7 Владимир
# 5 Юлия
# 4 Светлана
# Sample Output:
# 3: Сергей
# 5: Николай, Юлия
# 4: Елена, Светлана
# 7: Владимир

import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))

sample_output = {}
for el in lst_in:
    day, name = el.split()
    day = int(day)
    if day not in sample_output:
        sample_output[day] = name
    else:
        sample_output[day] += ', ' + name

print(*[f"{k}: {v}" for k, v in sample_output.items()], sep='\n')


# Подвиг 7. Объявите в программе словарь с наименованиями предметов и их весом (в граммах):
# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300, 
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
                 
# Сергей собирается в поход и готов взвалить на свои хрупкие плечи максимальный вес в N кг (вводится с клавиатуры). Он решил класть в рюкзак предметы в порядке убывания их веса (сначала самые тяжелые, затем, все более легкие) так, чтобы их суммарный вес не превысил значения N кг. Все предметы даны в единственном экземпляре. Выведите список предметов (в строчку через пробел), которые берет с собой Сергей в порядке убывания их веса.
# Sample Input:
# 10
# # Sample Output:
# палатка брезент удочка брюки пила карандаш спички

things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300,'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200, 'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}

max_weight_kg = int(input())
max_weight_g = max_weight_kg * 1000

sorted_things = dict(sorted(things.items(), key=lambda item: item[1], reverse=True))

things_for_Sergey = {}

while max_weight_g > 0 and sorted_things:
    for item, weight in sorted_things.items():
        if weight <= max_weight_g:
            things_for_Sergey[item] = weight
            max_weight_g -= weight
            del sorted_things[item]
            break

print(*things_for_Sergey.keys())