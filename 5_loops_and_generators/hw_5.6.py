from itertools import count
from unittest import result
import pytest

# TODO: 5.6 Вложенные циклы

# Подвиг 1. На вход программе подается натуральное число N (то есть, положительное, целое). Требуется его прочитать и создать двумерный (вложенный) список размером N x N элементов, состоящий из всех единиц, а затем, в последний столбец записать пятерки. Вывести этот список на экран в виде таблицы чисел, как показано в примере ниже.
# P.S. Будьте внимательны в конце строк пробелов быть не должно!
# Sample Input:
# 4
# Sample Output:
# 1 1 1 5
# 1 1 1 5
# 1 1 1 5
# 1 1 1 5

# n = int(input())
# matrix = []
# for i in range(n):
#     row = []
#     for j in range(n):
#         if j == n - 1:
#             row.append(5)
#         else:
#             row.append(1)
#     matrix.append(row)
# for row in matrix:
# print(*row)
 

# Подвиг 2. На вход программе подаются строки (URL-адреса, каждая с новой строки). В программе уже реализовано их чтение и сохранение в списке:
# lst_in = list(map(str.strip, sys.stdin.readlines()))              
# Требуется заменить в строках списка lst_in все пробелы на символ дефиса (-). Следует учесть, что может быть несколько подряд идущих пробелов. Полученные URL-адреса (строки) вывести на экран в столбик в порядке их следования в списке lst_in.
# Sample Input:
# django chto  eto takoe    poryadok ustanovki
# model mtv   marshrutizaciya funkcii  predstavleniya
# marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya
# Sample Output:
# django-chto-eto-takoe-poryadok-ustanovki
# model-mtv-marshrutizaciya-funkcii-predstavleniya
# marshrutizaciya-obrabotka-isklyucheniy-zaprosov-perenapravleniya

# import sys
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# for i, row in enumerate(lst_in):
#     while row.count('  ') > 0:
#         row = row.replace('  ', ' ')
#         lst_in[i] = row
#     lst_in[i] = row.replace(' ', '-')
# print(*lst_in, sep='\n')


# Подвиг 3. На вход программе подается натуральное число n. Необходимо его прочитать и найти все простые числа (нацело делятся только на 1 и на себя), которые меньше числа n, то есть, в диапазоне [2; n). Результат вывести на экран в строчку через пробел.
# Ликбез: квадратная скобка - граница включается; круглая скобка - граница исключается. Например [2; n) - диапазон от 2 до n-1 целых чисел.
# Sample Input:
# 11
# Sample Output:
# 2 3 5 7

# n = int(input())
# result = []
# for i in range(2, n):
#     is_prime = True
#     for j in range(2, int(i**0.5) + 1):
#         if i % j == 0:
#             is_prime = False
#             break
#     if is_prime:
#         result.append(i)
# print(*result)    


# Подвиг 4. На вход программе подается двумерный список размерностью 5 х 5 элементов, состоящий из нулей и в некоторых позициях единицы (см. пример ниже). В программе уже реализовано их чтение и сохранение в списке:
# s = sys.stdin.readlines()
# lst_in = [list(map(int, x.strip().split())) for x in s]         
# Требуется проверить, не касаются ли единицы друг друга по горизонтали, вертикали и диагонали. То есть, вокруг каждой единицы должны быть нули. Если проверка проходит вывести на экран "ДА", иначе "НЕТ".
# Sample Input:
# 1 0 0 0 0
# 0 0 1 0 1
# 0 0 0 0 0
# 0 1 0 1 0
# 0 0 0 0 0
# Sample Output:
# ДА

# import sys
# s = sys.stdin.readlines()
# lst_in = [list(map(int, x.strip().split())) for x in s]
# n = len(lst_in) - 1

# for i in range(n):
#     for j in range(n):        
#         if lst_in[i][j] + lst_in[i + 1][j] + lst_in[i + 1][j + 1] + lst_in[i][j + 1] > 1:
#             print('НЕТ')
#             break
#     else:
#         continue
#     break
# else:
#     print('ДА')


# Подвиг 5. На вход программе подается двумерный список размерностью 5 х 5 элементов, состоящий из целых чисел (пример см. ниже). В программе уже реализовано их чтение и сохранение в списке:
# s = sys.stdin.readlines()
# lst_in = [list(map(int, x.strip().split())) for x in s]                
# Необходимо проверить, является ли этот двумерный список симметричным относительно главной диагонали. Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива в правый нижний. Выведите на экран "ДА", если матрица (таблица чисел) симметрична и "НЕТ" в противном случае.
# Sample Input:
# 2 3 4 5 6
# 3 2 7 8 9
# 4 7 2 0 4
# 5 8 0 2 1
# 6 9 4 1 2
# Sample Output:
# ДА

# import sys
# s = sys.stdin.readlines()
# lst_in = [list(map(int, x.strip().split())) for x in s]
# n = len(lst_in)
# flag = True
# for i in range(n):
#     for j in range(i + 1, n):
#         if lst_in[i][j] != lst_in[j][i]:
#             flag = False
#             break
#     if not flag:
#         break
# if flag:
#     print('ДА')
# else:
#     print('НЕТ')


# Большой подвиг 6. На вход программе подаются целые числа, записанные в одну строку через пробел. Необходимо их прочитать и сохранить в списке. Затем, выполнить сортировку выбором полученного списка по возрастанию (неубыванию). Идея алгоритма очень проста и проиллюстрирована на рисунке ниже.
# Вначале мы рассматриваем первый элемент списка и ищем второй минимальный относительно первого элемента (включая и его). На рисунке - это последний элемент со значением -1. Затем, меняем местами первый и последний элементы. Переходим ко второму элементу списка и повторяем эту же процедуру, но относительно второго элемента (то есть, первый уже не рассматриваем). На рисунке минимальный элемент - это 2, поэтому менять местами здесь ничего не нужно. Переходим к 3-му элементы со значением 6. Относительно него находим минимальный элемент - это 3. Меняем их местами. 
# Вот идея алгоритма сортировки выбором. Реализуйте его для сформированного списка целых чисел. Результат выведите на экран в виде последовательности чисел, записанных в одну строчку через пробел.
# Sample Input:
# 8 11 -53 2 10 11
# Sample Output:
# -53 2 8 10 11 11

# numbers = list(map(int, input().split()))
# n = len(numbers)

# for i in range(n):
#     min_index = i
#     for j in range(i + 1, n):
#         if numbers[j] < numbers[i]:
#             min_index = j
#             numbers[i], numbers[min_index] = numbers[min_index], numbers[i]
# print(*numbers)


# Большой подвиг 7. На вход программе подаются целые числа, записанные в одну строку через пробел. Необходимо их прочитать и сохранить в списке. Затем, выполнить сортировку полученного списка по возрастанию (неубыванию) методом всплывающего пузырька. Идея алгоритма проста и показана на рисунке ниже.
# При первом проходе перебираем все соседние пары элементов и если значение предыдущего элемента (слева) больше значения следующего (справа), то они меняются местами. (На рисунке 3 и 2 меняются местами). Следующая пара - это 3 и 6. Они уже выстроены по возрастанию, поэтому ничего не делаем и переходим к следующей паре 6 и -1. Меняем значения местами и видим, что на последнем месте находится максимальное значение 6, что нам и нужно.
# При втором проходе делаем все то же самое, но доходим до предпоследнего элемента, так как последнее значение 6 уже отсортировано. На третьем проходе исключаем уже последние два элемента и так далее. То есть, в этом алгоритме достаточно сделать N-1 проходов, где N - длина списка.
# Вот идея алгоритма сортировки всплывающего пузырька. Реализуйте его для вводимого списка целых чисел. Результат выведите на экран в виде последовательности чисел, записанных в одну строчку через пробел.
# Sample Input:
# 4 5 2 0 6 3 -56 3 -1
# Sample Output:
# -56 -1 0 2 3 3 4 5 6

# numbers = list(map(int, input().split()))
# n = len(numbers)
# for i in range(n - 1):
#     for j in range(n - 1 - i):
#         if numbers[j] > numbers[j + 1]:
#             numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j] 
# print(*numbers)


# Подвиг 8. В некоторой стране используются денежные купюры достоинством в 1, 2, 4, 8, 16, 32 и 64. На вход программы подается натуральное число n. Необходимо его прочитать. Затем определите, каким наименьшим количеством денежных купюр достоинством в 1, 2, 4, 8, 16, 32 и 64 можно выплатить сумму n? выведите на экран список купюр для формирования суммы n (в одну строчку через пробел, начиная с наибольшей и заканчивая наименьшей). Предполагается, что имеется достаточно большое количество купюр всех достоинств.
# P.S. Программа может быть реализована и без вложенных циклов.
# Sample Input:
# 221
# Sample Output:
# 64 64 64 16 8 4 1

n = int(input())
denominations = [64, 32, 16, 8, 4, 2, 1]
result = []
for d in denominations:
    while n >= d:
        n -= d
        result.append(d)
print(*result)


    



        